/*
 * Copyright (c) 2023, 2025, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */
package opentelemetry.core;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.github.tomakehurst.wiremock.stubbing.ServeEvent;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;

import com.oracle.coherence.common.base.Blocking;

import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;

import io.opentelemetry.proto.common.v1.AnyValue;
import io.opentelemetry.proto.common.v1.KeyValue;

import io.opentelemetry.proto.trace.v1.Span;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import java.util.function.Predicate;

import java.util.stream.Collectors;

import com.github.tomakehurst.wiremock.http.Request;

import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
import static com.github.tomakehurst.wiremock.client.WireMock.post;
import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;
import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;

/**
 * Testing utilities.
 *
 * @author rl 9.22.2023
 * @since 24.03
 */
public class TestingUtils
    {
    /**
     * Create a mock server bound to the specified port.
     *
     * @param nPort  the listen port
     *
     * @return a mock server bound to the specified port
     */
    public static WireMockServer createMockServer(int nPort)
        {
        WireMockServer wireMockServer =
                new WireMockServer(options().port(nPort));

        wireMockServer.start();

        // Stub to match any request
        wireMockServer.stubFor(post(urlEqualTo("/v1/traces"))
                                       .willReturn(aResponse()
                                                           .withStatus(200)
                                                           .withBody("OK")));

        return wireMockServer;
        }

    /**
     * Extract spans and return a {@link List} of {@link Span}s.
     *
     * @param server  the mock server
     *
     * @return a {@link List} of {@link Span}s recorded by the mock server
     */
    public static List<Span> extractSpans(WireMockServer server)
        {
        // Get all recorded requests
        List<ServeEvent> serveEvents = server.getAllServeEvents();

        List<Span> spans = serveEvents.stream()
                .map(ServeEvent::getRequest)
                .map(Request::getBody)
                .map(TestingUtils::getExportTraceServiceRequest)
                .flatMap(Optional::stream)
                .flatMap(r -> r.getResourceSpansList().stream())
                .flatMap(r -> r.getScopeSpansList().stream())
                .flatMap(r -> r.getSpansList().stream())
                .collect(Collectors.toList());

        return spans;
        }

    /**
     * Create an {@link ExportTraceServiceRequest} from the provided body.
     *
     * @param body  the request body as a byte[]
     *
     * @return {@link ExportTraceServiceRequest}, if any, from the provided
     *         body
     */
    public static Optional<ExportTraceServiceRequest> getExportTraceServiceRequest(byte[] body)
        {
        try
            {
            return Optional.ofNullable(ExportTraceServiceRequest.parseFrom(body));
            }
        catch (InvalidProtocolBufferException e)
            {
            return Optional.empty();
            }
        }

    /**
     * Return a list of {@link Span spans} for the specified operations that
     * were generated by the specified member.
     *
     * @param listSpans  the {@link Span spans} to filter
     * @param aOpNames   the {@link Span spans} operations names
     *
     * @return a list of {@link Span spans} for the specified operations that
     *         were generated by the specified member
     */
    public static List<Span> getSpans(List<Span> listSpans, String... aOpNames)
        {
        return getSpans(listSpans, aOpNames, -1);
        }

    /**
     * Returns a {@code List} of spans that have the same trace ID as the
     * given top-level, or parent, {@link Span}.
     *
     * @param spanParent  the parent {@link Span}
     * @param listSpans   the spans associated with the trace ID of the given
     *                    parent
     *
     * @return a {@code List} of spans that have the same trace ID as the
     *         given top-level, or parent, {@link Span}
     *
     * @since 15.1.1.0
     */
    public static List<Span> getSpansAssociatedWith(Span spanParent, List<Span> listSpans)
        {
        if (listSpans == null)
            {
            throw new IllegalArgumentException("listSpans cannot be null");
            }

        if (spanParent == null)
            {
            throw new IllegalArgumentException("spanParent cannot be null");
            }

        ByteString traceId = spanParent.getTraceId();

       return listSpans.stream()
                .filter(s -> s.getTraceId().equals(traceId) && s.getTraceId() != traceId)
                .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
        }

    /**
     * Returns a {@link SpanNode} representing the complete graph for all
     * {@link Span}s with the same trace ID as the given parent {@link Span}.
     *
     * @param spanParent the parent {@link Span}
     * @param listSpans  a {@link List} of {@link Span}s associated with
     *                   the given parent span
     *
     * @return a {@link SpanNode} representing the complete graph for all
     *         {@link Span}s with the same trace ID as the given parent
     *         {@link Span}
     *
     * @since 15.1.1.0
     */
    public static SpanNode getSpanTree(Span spanParent, List<Span> listSpans)
        {
        SpanNode root = new SpanNode(spanParent);

        doProcess(root, listSpans);

        return root;
        }

    /**
     * Create a graph of {@link SpanNode} instances based on the
     * {@link Span} in the given list using the provided {@link SpanNode}
     * as the root node.
     *
     * @param spanNodeParent  the parent {@link SpanNode}
     * @param listSpans       the {@link Span}s which will be used to
     *                        create the returned graph
     *
     * @since 15.1.1.0
     */
    private static void doProcess(SpanNode spanNodeParent, List<Span> listSpans)
        {
        List<Span> listToRemove = new ArrayList<>();
        ByteString rootSpanId   = spanNodeParent.getSpanId();

        for (Span s : listSpans)
            {
            if (s.getParentSpanId().equals(rootSpanId))
                {
                spanNodeParent.addChild(new SpanNode(s));
                listToRemove.add(s);
                }
            }

        listSpans.removeAll(listToRemove);

        if (spanNodeParent.hasChildren())
            {
            for (Node s : spanNodeParent.getChildren())
                {
                doProcess((SpanNode) s, listSpans);
                }
            }
        }

    /**
     * Return a list of {@link Span spans} for the specified operations that
     * were generated by the specified member.
     *
     * @param listSpans  the {@link Span spans} to filter
     * @param aOpNames   the {@link Span spans} operations names
     * @param nMember    the member which generated the {@link Span spans}
     *
     * @return a list of {@link Span spans} for the specified operations that
     *         were generated by the specified member
     */
    public static List<Span> getSpans(List<Span> listSpans, String[] aOpNames, long nMember)
        {
        if (aOpNames == null || aOpNames.length == 0)
            {
            throw new IllegalArgumentException("aOpNames cannot be null or empty");
            }

        if (listSpans == null)
            {
            throw new IllegalArgumentException("listSpans cannot be null");
            }

        // build an or-based predicate using provided operation names
        Predicate<String> predicate = Arrays.stream(aOpNames)
                .map(s -> (Predicate<String>) s::equals)
                .reduce(Predicate::or).orElseThrow();

        if (nMember < 1)
            {
            return listSpans.stream()
                    .filter(span -> predicate.test(span.getName()))
                    .collect(Collectors.toList());
            }
        else
            {
            // filter and return the spans
            return listSpans.stream()
                    .filter(span -> predicate.test(span.getName()))
                    .filter(span -> getMetadata(span).get("member").getIntValue() == nMember)
                    .collect(Collectors.toList());
            }
        }

    /**
     * Obtain a {@link Map map} of the metadata associated with the provided
     * {@link Span span}.
     *
     * @param span  the span from which metadata is to be extracted
     *
     * @return a {@link Map map} of the metadata associated with the provided
     *         {@link Span span}
     */
    public static Map<String, AnyValue> getMetadata(Span span)
        {
        return span.getAttributesList().stream()
                .collect(Collectors.toMap(KeyValue::getKey, KeyValue::getValue));
        }

    /**
     * Waits for the {@code OpenTelemetry} runtime to complete exporting
     * {@link Span spans}.
     *
     * @return a {@link List list} of all exported {@link Span spans}.
     */
    public static List<Span> waitForAllSpans(WireMockServer server)
        {
        int cLast = 0;
        int cAttempts = 1;
        int cMaxAttempts = 10;

        for (int i = 0; i < 50; i++)
            {
            List<Span> listSpans = TestingUtils.extractSpans(server);
            int cCurrent = listSpans.size();
            if (cLast == cCurrent)
                {
                if (cAttempts == cMaxAttempts)
                    {
                    return listSpans;
                    }
                cAttempts++;
                }
            else
                {
                cAttempts = 0;
                }
            cLast = cCurrent;
            try
                {
                Blocking.sleep(500);
                }
            catch (InterruptedException e)
                {
                throw new RuntimeException(e);
                }
            }
        throw new IllegalStateException("Spans still being produced after 50 attempts to check for a stable count");
        }

    /**
     * Enums for expected cache event mutation types.
     */
    @SuppressWarnings("unused")
    public enum MutationType
        {
            /**
             * MapEvent insert.
             */
            inserted,

            /**
             * MapEvent update.
             */
            updated,

            /**
             * MapEvent deleted.
             */
            deleted,

            /**
             * No event.
             */
            none,
        }

    // ----- inner class: ControlTree ---------------------------------------

    /**
     * The {@code ControlNode} is used by tests to build the expected
     * tracing {@link Span} graph.
     *
     * @since 15.1.1.0
     */
    public static class ControlNode
            extends Node
        {
        // ----- constructors -----------------------------------------------

        /**
         * Constructs a {@code ControlNode}.
         *
         * @param sName  the tracing {@link Span} name this node represents
         */
        public ControlNode(String sName)
            {
            f_sName = sName;
            }

        // ----- TreeNode methods -------------------------------------------

        /**
         * Returns the name of this node.
         *
         * @return the name of this node
         */
        public String getName()
            {
            return f_sName;
            }

        /**
         * Adds one or more children to this node.
         *
         * @param children the children to be added
         *
         * @return this node
         */
        public ControlNode addChildren(ControlNode... children)
            {
            for (Node child : children)
                {
                addChild(child);
                }

            return this;
            }

        // ----- api --------------------------------------------------------

        /**
         * Creates a graph of {@link ControlNode}s based on the given
         * map which contains the data loaded {@code golden} file describing
         * the expected tracing graph.
         *
         * @param map     the data containing the expected graph structure
         * @param parent  the parent node
         *
         * @return the complete trace graph
         */
        @SuppressWarnings({"rawtypes"})
        public static ControlNode loadFrom(Map map, ControlNode parent)
            {
            ControlNode node     = new ControlNode(map.get("name").toString());
            List        children = (List) map.get("children");

            if (parent == null)
                {
                parent = node;
                }
            else
                {
                parent.addChild(node);
                }

            if (children != null)
                {
                for (Object child : children)
                    {
                    loadFrom((Map) child, node);
                    }
                }

            return parent;
            }

        // ----- data members -----------------------------------------------

        /**
         * The name of this node.
         */
        protected final String f_sName;
        }

    // ----- inner class: Node ------------------------------------------

    /**
     * Base class used to build tree structures that describe the
     * sequence of spans generated by a single cache operation.
     *
     * @since 15.1.1.0
     */
    protected static abstract class Node
        {
        /**
         * The name of the cache operation.
         *
         * @return  the name of the cache operation
         */
        public abstract String getName();

        /**
         * Adds the provided node as a child to this node.
         *
         * @param child  the child to add
         *
         * @return this node
         */
        @SuppressWarnings("UnusedReturnValue")
        public Node addChild(Node child)
            {
            f_children.add(child);

            return this;
            }

        /**
         * Returns the children of this node.
         *
         * @return the children of this node.  If this node has no children,
         *         this returns an empty {@code List}
         */
        public List<Node> getChildren()
            {
            return f_children;
            }

        /**
         * Returns {@code true} if this node has children.
         *
         * @return {@code true} if this node has children
         */
        public boolean hasChildren()
            {
            return !f_children.isEmpty();
            }

        @Override
        public boolean equals(Object o)
            {
            if (!(o instanceof Node treeNode))
                {
                return false;
                }
            return Objects.equals(getName(), treeNode.getName())
                   && Objects.equals(f_children, treeNode.f_children);
            }

        @Override
        public int hashCode()
            {
            return Objects.hashCode(f_children);
            }

        @Override
        public String toString()
            {
            return "{name=" + getName() +
                   ", children=" + f_children +
                   '}';
            }

        /**
         * Returns the {@link String} representation (as a tree) of this
         * node and any children it may have.
         *
         * @return {@link String} representation (as a tree) of this
         *         node and any children it may have
         */
        public String toStringTree()
            {
            StringBuilder sb = new StringBuilder();

            printTree(sb, this, "");

            return sb.toString();
            }

        // ----- helper methods ---------------------------------------------

        /**
         * Used to recursively write the structure of the given Node(s)
         * to the provided {@link StringBuilder}
         *
         * @param sb      the {@link StringBuilder}
         * @param node    the current {@link Node}
         * @param indent  the {@link String} to use for indentation
         */
        private static void printTree(StringBuilder sb, Node node, String indent)
            {
            sb.append(indent).append("- ").append(node.getName()).append("\n");
            node.getChildren().forEach(child -> printTree(sb, child, indent + "  "));
            }

        // ----- data members -----------------------------------------------

        /**
         * This node's children.
         */
        private final List<Node> f_children = new ArrayList<>();
        }

    // ----- inner class: SpanTree ------------------------------------------

    /**
     * Wraps the given {@link Span} within a {@link SpanNode}.  This allows
     * taking a list of captured {@link Span}s and generating a graph of nodes
     * based on the parent/child relationship between the spans in the same
     * trace ID.
     *
     * @since 15.1.1.0
     */
    public static final class SpanNode
            extends Node
        {
        // ----- constructors -----------------------------------------------

        /**
         * Constructs a new {@code SpanNode}.
         *
         * @param span the Span for this node in the graph.
         */
        public SpanNode(Span span)
            {
            f_span = span;
            }

        // ----- TreeNode methods -------------------------------------------

        @Override
        public String getName()
            {
            return f_span.getName();
            }

        @Override
        public Node addChild(Node child)
            {
            super.addChild(child);

            if (child instanceof SpanNode)
                {
                super.getChildren().sort((o1, o2) ->
                     {
                     SpanNode spanNode1 = (SpanNode) o1;
                     SpanNode spanNode2 = (SpanNode) o2;

                     int nComp = Long.compare(spanNode1.f_span.getStartTimeUnixNano(), spanNode2.f_span.getStartTimeUnixNano());
                     if (nComp == 0)
                         {
                         if (spanNode1.getName().endsWith(".post"))
                             {
                             return 1;
                             }
                         }

                     return nComp;
                     });
                }

            return this;
            }

        // ----- api --------------------------------------------------------

        /**
         * Returns the ID of the associated {@link Span}
         *
         * @return the ID of the associated {@link Span}
         */
        public ByteString getSpanId()
            {
            return f_span.getSpanId();
            }

        // ----- data members -----------------------------------------------

        /**
         * The {@link Span} for this node.
         */
        private final Span f_span;
        }
    }
