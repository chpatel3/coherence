/*
 * Copyright (c) 2025, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */
package opentelemetry.core;

import com.github.tomakehurst.wiremock.WireMockServer;

import com.oracle.bedrock.junit.CoherenceClusterExtension;

import com.oracle.bedrock.runtime.LocalPlatform;

import com.oracle.bedrock.runtime.coherence.CoherenceCluster;

import com.oracle.bedrock.runtime.coherence.options.ClusterPort;
import com.oracle.bedrock.runtime.coherence.options.LocalHost;
import com.oracle.bedrock.runtime.coherence.options.LocalStorage;
import com.oracle.bedrock.runtime.coherence.options.Logging;
import com.oracle.bedrock.runtime.coherence.options.Multicast;
import com.oracle.bedrock.runtime.coherence.options.RoleName;

import com.oracle.bedrock.runtime.java.options.ClassName;
import com.oracle.bedrock.runtime.java.options.IPv4Preferred;
import com.oracle.bedrock.runtime.java.options.SystemProperty;

import com.oracle.bedrock.runtime.options.DisplayName;
import com.oracle.bedrock.runtime.options.StabilityPredicate;

import com.oracle.bedrock.testsupport.junit.AbstractTestLogs;

import com.oracle.coherence.common.base.Blocking;
import com.oracle.coherence.common.base.Logger;

import com.tangosol.net.Coherence;
import com.tangosol.net.CoherenceConfiguration;
import com.tangosol.net.NamedMap;
import com.tangosol.net.Session;
import com.tangosol.net.SessionConfiguration;

import com.tangosol.util.Aggregators;
import com.tangosol.util.Filters;
import com.tangosol.util.Processors;
import com.tangosol.util.SimpleMapEntry;
import com.tangosol.util.SynchronousListener;
import com.tangosol.util.ValueExtractor;

import com.tangosol.util.listener.SimpleMapListener;

import io.opentelemetry.proto.trace.v1.Span;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import java.util.Set;

import java.util.concurrent.TimeUnit;

import opentelemetry.core.TestingUtils.ControlNode;
import opentelemetry.core.TestingUtils.SpanNode;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import org.junit.jupiter.api.extension.RegisterExtension;

import org.snakeyaml.engine.v2.api.Load;
import org.snakeyaml.engine.v2.api.LoadSettings;

import static opentelemetry.core.TestingUtils.getSpanTree;
import static opentelemetry.core.TestingUtils.getSpans;
import static opentelemetry.core.TestingUtils.getSpansAssociatedWith;
import static opentelemetry.core.TestingUtils.waitForAllSpans;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.greaterThan;

/**
 * Tests to validate traces generated by the extend client, proxy,
 * and storage members.
 *
 * @author rl 6.5.2025
 * @since 25.03.3
 */
@SuppressWarnings("ResultOfMethodCallIgnored")
public class NamedCacheOperationsTracingIT
    {
    static
        {
        System.setProperty("coherence.tracing.ratio",     "1.0");
        System.setProperty("mockserver.logLevel",         "OFF");
        System.setProperty("otel.service.name",           "client");
        System.setProperty("otel.traces.exporter",        "otlp");
        System.setProperty("otel.bsp.schedule.delay",     "200");
        System.setProperty("otel.exporter.otlp.protocol", "http/protobuf");
        }

    // ---- test lifecycle --------------------------------------------------

    @BeforeAll
    public static void beforeAll()
        {
        ensureSession();

        // NOTE: If it's desired to see how the spans generated by this
        //       test appear in Jaeger's UI, comment out the line
        //       below and run the following command in a terminal:
        //
        //           docker run --rm --name jaeger \
        //                  -p 16686:16686 \
        //                  -p 4317:4317 \
        //                  -p 4318:4318 \
        //                  -p 5778:5778 \
        //                  -p 9411:9411 \
        //                  jaegertracing/jaeger:2.6.0
        //
        //       Run one or more of the tests and access the Jaeger UI
        //       via your browser at http://localhost:16686
        m_mockServer = TestingUtils.createMockServer(4318);
        }

    @AfterAll
    public static void afterAll()
        {
        destroySession();
        if (m_mockServer != null)
            {
            m_mockServer.stop();
            }
        }

    @AfterEach
    public void afterEach()
        {
        if (m_mockServer != null)
            {
            m_mockServer.resetRequests();
            }

        getMap().clear();
        }

    // ----- test methods ---------------------------------------------------

    @Test
    @Disabled
    public void ensureCache()
            throws Exception
        {
        runTest(() -> getMap("ensure"), "extend.EnsureCache.post", "EnsureCache");
        }

    @Test
    @Disabled
    public void destroyCache()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getMap("destroyCache");

                Blocking.sleep(1000);

                map.destroy();

                }, "cache.Destroy", "DestroyCache");
        }

    @Test
    public void put()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getMap();

                map.put("a", "b");

                }, "cache.Put", "Put");
        }

    @Test
    public void putAll()
            throws Exception
        {
        runTest(this::getPopulatedMap, "cache.PutAll", "PutAll");
        }

    @Test
    public void get()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getMap();

                map.get("a");

                }, "cache.Get", "Get");
        }

    @Test
    public void remove()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getMap();

                map.remove("a");

                }, "cache.Remove", "Remove");
        }

    @Test
    public void keySetIteration()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                for (Iterator<String> i = map.keySet().iterator(); i.hasNext(); )
                    {
                    i.next();
                    if (!i.hasNext())
                        {
                        i.remove();
                        }
                    }

                }, "cache.KeySet", "KeySetIteration");
        }

    @Test
    public void keySetContainsAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<String> keys = map.keySet();
                keys.containsAll(Set.of("a", "b", "c"));

                }, "cache.KeySet", "KeySetContainsAll");
        }

    @Test
    public void keySetClear()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<String> keys = map.keySet();
                keys.clear();

                }, "cache.KeySet", "KeySetClear");
        }

    @Test
    public void keySetRemoveAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<String> keys = map.keySet();
                keys.removeAll(Set.of("a", "c"));

                }, "cache.KeySet", "KeySetRemoveAll");
        }

    @Test
    public void keySetRetainAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<String> keys = map.keySet();
                keys.retainAll(Set.of("a", "c"));

                }, "cache.KeySet", "KeySetRetainAll");
        }

    @Test
    public void keySetSize()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<String> keys = map.keySet();
                keys.size();

                }, "cache.KeySet", "KeySetSize");
        }

    @Test
    public void keySetIsEmpty()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<String> keys = map.keySet();
                keys.isEmpty();

                }, "cache.KeySet", "KeySetIsEmpty");
        }

    @Test
    public void size()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getMap();

                map.size();

                }, "cache.Size", "Size");
        }

    @Test
    public void empty()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getMap();

                map.isEmpty();

                }, "cache.IsEmpty", "IsEmpty");
        }

    @Test
    public void clear()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getMap();

                map.clear();

                }, "cache.Clear", "Clear");
        }

    @Test
    public void truncate()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                map.truncate();

                }, "cache.Truncate", "Truncate");
        }

    @Test
    public void containsKey()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getMap();

                map.put("a", "b");

                map.containsKey("a");

                }, "cache.ContainsKey", "ContainsKey");
        }

    @Test
    public void containsValue()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getMap();

                map.put("a", "b");

                map.containsValue("b");

                }, "cache.ContainsValue", "ContainsValue");
        }

    @Test
    public void entrySetIteration()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                for (Iterator<Map.Entry<String, String>> i = map.entrySet().iterator(); i.hasNext(); )
                    {
                    i.next();
                    if (!i.hasNext())
                        {
                        i.remove();
                        }
                    }

                }, "cache.EntrySet", "EntrySetIteration");
        }

    @Test
    public void entrySetContainsAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<Map.Entry<String, String>> entries = map.entrySet();

                Set<Map.Entry<String, String>> setTest = new HashSet<>();
                setTest.add(new SimpleMapEntry<>("a", "b"));
                setTest.add(new SimpleMapEntry<>("c", "d"));

                entries.containsAll(setTest);

                }, "cache.EntrySet", "EntrySetContainsAll");
        }

    @Test
    public void entrySetClear()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<Map.Entry<String, String>> entries = map.entrySet();
                entries.clear();

                }, "cache.EntrySet", "EntrySetClear");
        }

    @Test
    public void entrySetRemoveAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<Map.Entry<String, String>> entries = map.entrySet();
                entries.removeAll(Set.of(new SimpleMapEntry<>("a", "b")));

                }, "cache.EntrySet", "EntrySetRemoveAll");
        }

    @Test
    public void entrySetRetainAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<Map.Entry<String, String>> entries = map.entrySet();
                entries.retainAll(Set.of(new SimpleMapEntry<>("a", "b")));

                }, "cache.EntrySet", "EntrySetRetainAll");
        }

    @Test
    public void entrySetSize()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<Map.Entry<String, String>> entries = map.entrySet();
                entries.size();

                }, "cache.EntrySet", "EntrySetSize");
        }

    @Test
    public void entrySetIsEmpty()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Set<Map.Entry<String, String>> entries = map.entrySet();
                entries.isEmpty();

                }, "cache.EntrySet", "EntrySetIsEmpty");
        }

    @Test
    public void aggregate()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                map.aggregate(Aggregators.count());

                }, "cache.FilteredAggregate", "AggregateFilter");
        }

    @Test
    public void invoke()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                map.invoke("a", Processors.touch());

                }, "cache.Invoke", "Invoke");
        }

    @Test
    public void invokeAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                map.invokeAll(Set.of("a", "c", "e"), Processors.touch());

                }, "cache.KeysInvokeAll", "InvokeAll");
        }

    @Test
    public void invokeAllFilter()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                map.invokeAll(Filters.present(), Processors.touch());

                }, "cache.FilteredInvokeAll", "InvokeAllFilter");
        }

    @Test
    @Disabled
    public void addIndex()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                map.addIndex(ValueExtractor.identity());

                }, "cache.AddIndex", "AddIndex");
        }

    @Test
    public void listenerKey()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap("keyListener");

                map.addMapListener(new SimpleMapListener<>(), "a", false);

                }, "cache.AddKeyMapListener", "ListenerKey");
        }

    @Test
    public void listenerFilter()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap("filterListener");

                map.addMapListener(new SimpleMapListener<>(), Filters.present(), false);

                }, "cache.AddFilteredMapListener", "ListenerFilter");
        }

    @Test
    public void filterMapEvent()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap("mapEvent");

                map.addMapListener(new SimpleMapListener<>(), Filters.present(), false);

                map.put("m", "n");

                }, "cache.Put", "FilterMapEvent");
        }

    @Test
    public void filterMapEventSynchronous()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap("mapEventSync");

                map.addMapListener(new SyncListener<>(), Filters.present(), false);

                map.put("m", "n");

                }, "cache.Put", "FilterMapEvent");
        }

    @Test
    public void keyMapEvent()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap("mapEvent");

                map.addMapListener(new SimpleMapListener<>(), "a", false);

                map.put("a", "z");

                }, "cache.Put", "KeyMapEvent");
        }

    @Test
    public void keyMapEventSynchronous()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap("mapEventSync");

                map.addMapListener(new SyncListener<>(), "a", false);

                map.put("a", "z");

                }, "cache.Put", "KeyMapEvent");
        }

    @Test
    public void valuesIteration()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                for (Iterator<String> i = map.values().iterator(); i.hasNext(); )
                    {
                    i.next();
                    if (!i.hasNext())
                        {
                        i.remove();
                        }
                    }

                }, "cache.Values", "ValuesIteration");
        }

    @Test
    public void valuesContainsAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Collection<String> values = map.values();
                values.containsAll(Set.of("b", "d", "f"));

                }, "cache.Values", "ValuesContainsAll");
        }

    @Test
    public void valuesClear()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Collection<String> values = map.values();
                values.clear();

                }, "cache.Values", "ValuesClear");
        }

    @Test
    @Disabled
    public void valuesRemoveAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Collection<String> values = map.values();
                values.removeAll(Set.of("b", "z"));

                }, "cache.Values", "ValuesRemoveAll");
        }

    @Test
    public void valuesRetainAll()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Collection<String> values = map.values();
                values.retainAll(Set.of("a", "c"));

                }, "cache.Values", "ValuesRetainAll");
        }

    @Test
    public void valuesSize()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Collection<String> values = map.values();
                values.size();

                }, "cache.Values", "ValuesSize");
        }

    @Test
    public void valuesIsEmpty()
            throws Exception
        {
        runTest(() ->
                {
                NamedMap<String, String> map = getPopulatedMap();

                Collection<String> values = map.values();
                values.isEmpty();

                }, "cache.Values", "ValuesIsEmpty");
        }

    // ----- inner class: TestBody ------------------------------------------

    /**
     * {@link FunctionalInterface} for providing cache logic for execution.
     */
    @FunctionalInterface
    protected interface CacheOperations
        {
        /**
         * Run the cache logic.
         *
         * @throws Exception if the test throws an unexpected exception
         */
        void run() throws Exception;
        }

    // ----- helper methods -------------------------------------------------

    /**
     * Load the {@code golden} file (in yaml format) for the specified
     * cache operation and return a Map that represents the expected
     * structure of the spans generated by the cache operation under
     * test.
     *
     * @param sOp  the cache operation
     *
     * @return the {@code golden} file encoded as a {@code Map}
     *         containing the expected structure of the traced
     *         cache operation
     */
    @SuppressWarnings("rawtypes")
    protected Map loadGolden(String sOp)
        {
        LoadSettings settings = LoadSettings.builder().build();
        Load         load     = new Load(settings);

        return (Map) load.loadFromInputStream(
                Thread.currentThread().getContextClassLoader().getResourceAsStream(sOp + ".yaml"));
        }

    /**
     * Run the specified {@link CacheOperations}.
     *
     * @param body  the {@link CacheOperations} to gather traces for
     * @param sOp   the name of the cache operation under test
     *
     * @throws Exception if an error occurs running the
     *         {@link CacheOperations}
     */
    protected void runTest(CacheOperations body, String sOp)
            throws Exception
        {
        runTest(body, sOp, null);
        }

    /**
     * Run the specified {@link CacheOperations}.  Following the completion
     * of that, gather the spans for the associated {@code sOp} and validate
     * the structure against the structure defined in the specified
     * {@code golden} file.
     *
     * @param body  the {@link CacheOperations} to gather traces for
     * @param sOp   the name of the cache operation under test
     * @param sFile the name of the {@code golden} file
     *
     * @throws Exception if an error occurs running the
     *         {@link CacheOperations}
     */
    protected void runTest(CacheOperations body, String sOp, String sFile)
            throws Exception
        {
        body.run(); // invoke cache operations to be traced

        if (sFile == null)
            {
            sFile = sOp;
            }

        if (m_mockServer != null)
            {
            List<Span> spans   = waitForAllSpans(m_mockServer);
            List<Span> results = getSpans(spans, sOp);

            assertThat(results.size(), greaterThan(0));

            Span span = null;
            for (Span result : results)
                {
                if (result.getParentSpanId().isEmpty())
                    {
                    span = result;
                    break;
                    }
                }

            List<Span>  listAssociatedSpans = getSpansAssociatedWith(span, spans);
            SpanNode    spansActual         = getSpanTree(span, listAssociatedSpans);
            ControlNode expected            = ControlNode.loadFrom(loadGolden(sFile), null);

            assertThat(String.format("Expected Span tree of\n%s received:\n%s",
                                     expected.toStringTree(),
                                     spansActual.toStringTree()),
                       spansActual,
                       is(expected));
            }
        else
            {
            Blocking.sleep(8000);
            }
        }

    /**
     * Creates the extend client {@link Session}.
     */
    protected static void ensureSession()
        {
        CoherenceConfiguration.Builder cfgBuilder = CoherenceConfiguration.builder();
        SessionConfiguration cfg = SessionConfiguration.builder()
                .named("test-session")
                .withMode(Coherence.Mode.Client)
                .withParameter("coherence.profile", "thin")
                .withParameter("coherence.wka",     "127.0.0.1")
                .build();

        cfgBuilder.withSession(cfg);

        Coherence coherence;
        try
            {
            //noinspection resource
            coherence = Coherence.clientBuilder(cfgBuilder.build(), Coherence.Mode.Client).build()
                    .start().get(5, TimeUnit.MINUTES);
            }
        catch (Exception e)
            {
            throw new RuntimeException(e);
            }

        m_extendCoherence = coherence;
        m_extendSession   = coherence.getSession("test-session");
        }

    /**
     * Destroys the extend client {@link Session}.
     */
    protected static void destroySession()
        {
        try
            {
            if (m_extendSession != null)
                {
                m_extendSession.close();
                }

            if (m_extendCoherence != null)
                {
                m_extendCoherence.close();
                }
            }
        catch (Exception e)
            {
            Logger.warn("Error closing session/coherence", e);
            }
        }

    /**
     * Returns the {@code dist} {@link NamedMap}.
     *
     * @return the {@code dist} {@link NamedMap}
     */
    protected <K, V> NamedMap<K, V> getMap()
        {
        return getMap("dist");
        }

    /**
     * Returns the specified {@link NamedMap}.
     *
     * @param sName the name of the {@link NamedMap}
     *
     * @return the {@code dist} {@link NamedMap}
     */
    protected <K, V> NamedMap<K, V> getMap(String sName)
        {
        return m_extendSession.getCache(sName);
        }

    /**
     * Returns the {@code dist} {@link NamedMap} pre-populated with
     * five entries.
     *
     * @return the {@code dist} {@link NamedMap} pre-populated with
     *         five entries
     */
    protected NamedMap<String, String> getPopulatedMap()
        {
        NamedMap<String, String> cache = getMap();

        cache.putAll(Map.of("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"));

        return cache;
        }

    /**
     * Returns the {@code dist} {@link NamedMap} pre-populated with
     * five entries.
     *
     * @param sName the name of the {@link NamedMap}
     *
     * @return the {@code dist} {@link NamedMap} pre-populated with
     *         five entries
     */
    protected NamedMap<String, String> getPopulatedMap(String sName)
        {
        NamedMap<String, String> cache = getMap(sName);

        cache.putAll(Map.of("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"));

        return cache;
        }

    // ----- inner class: SyncListener --------------------------------------

    /**
     * A synchronous version of {@link SimpleMapListener}.
     */
    public static class SyncListener<K, V>
            extends SimpleMapListener<K, V>
            implements SynchronousListener<K, V>
        {
        }

    // ----- data members ---------------------------------------------------

    /**
     * The mock server receiving tracing
     * {@link io.opentelemetry.api.trace.Span spans} generated by these
     * tests.
     */
    protected static WireMockServer m_mockServer;

    /**
     * The extend client session.
     */
    protected static Session m_extendSession;

    /**
     * The extend Coherence instance.
     */
    protected static Coherence m_extendCoherence;

    /**
     * This is a work-around to fix the fact that the JUnit5 test logs extension
     * in Bedrock does not work for BeforeAll methods and extensions.
     */
    static class TestLogs
            extends AbstractTestLogs
        {
        public TestLogs(Class<?> testClass)
            {
            init(testClass, "BeforeAll");
            }
        }

    /**
     * A Bedrock utility to capture logs of spawned processes into files
     * under target/test-output. This is added as an option to the cluster
     * and client processes.
     */
    static TestLogs logs = new TestLogs(NamedCacheOperationsTracingIT.class);

    /**
     * A Bedrock JUnit5 extension that starts a Coherence cluster made up of
     * two storage enabled members, two storage disabled members and two
     * storage disabled extend proxy members.
     */
    @RegisterExtension
    static CoherenceClusterExtension f_coherenceResource =
            new CoherenceClusterExtension()
                    .using(LocalPlatform.get())
                    .with(ClassName.of(Coherence.class),
                          Logging.at(9),
                          LocalHost.only(),
                          Multicast.ttl(0),
                          IPv4Preferred.yes(),
                          logs,
                          ClusterPort.automatic(),
                          SystemProperty.of("coherence.profile",           "thin"),
                          SystemProperty.of("coherence.tracing.ratio",     "1.0"),
                          SystemProperty.of("otel.traces.exporter",        "otlp"),
                          SystemProperty.of("otel.exporter.otlp.protocol", "http/protobuf"),
                          SystemProperty.of("otel.bsp.schedule.delay",     "200"),
                          StabilityPredicate.of(CoherenceCluster.Predicates.isCoherenceRunning()))
                    .include(1,
                             DisplayName.of("storage"),
                             RoleName.of("storage"),
                             SystemProperty.of("otel.service.name",       "storage"),
                             SystemProperty.of("coherence.proxy.enabled", "false"),
                             LocalStorage.enabled())
                    .include(1,
                             DisplayName.of("proxy"),
                             RoleName.of("proxy"),
                             SystemProperty.of("otel.service.name",       "proxy"),
                             SystemProperty.of("coherence.proxy.enabled", "true"),
                             LocalStorage.disabled());
    }
